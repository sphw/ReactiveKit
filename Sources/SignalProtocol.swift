//
//  The MIT License (MIT)
//
//  Copyright (c) 2016 Srdan Rasic (@srdanrasic)
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
//

import Dispatch
import Foundation

// MARK: - SignalProtocol

/// Represents a sequence of events.
public protocol SignalProtocol {

  /// The type of Xs generated by the signal.
  associatedtype X

  /// The type of error that can terminate the signal.
  associatedtype Error: Swift.Error

  /// Register the given observer.
  /// - Parameter observer: A function that will receive events.
  /// - Returns: A disposable that can be used to cancel the observation.
  func observe(with observer: @escaping Observer<X, Error>) -> Disposable
}

extension SignalProtocol {

  /// Register an observer that will receive events from a signal.
  public func observe<O: ObserverProtocol>(with observer: O) -> Disposable
    where O.X == X, O.Error == Error {
    return observe(with: observer.on)
  }

  /// Register an observer that will receive Xs from `.next` events of the signal.
  public func observeNext(with observer: @escaping (X) -> Void) -> Disposable {
    return observe { event in
      if case .next(let X) = event {
        observer(X)
      }
    }
  }

  /// Register an observer that will receive Xs from `.failed` events of the signal.
  public func observeFailed(with observer: @escaping (Error) -> Void) -> Disposable {
    return observe { event in
      if case .failed(let error) = event {
        observer(error)
      }
    }
  }

  /// Register an observer that will be executed on `.completed` event.
  public func observeCompleted(with observer: @escaping () -> Void) -> Disposable {
    return observe { event in
      if case .completed = event {
        observer()
      }
    }
  }
}

// MARK: - Extensions

// MARK: Creating a signal

public extension SignalProtocol {

  /// Create a signal that emits given X and then completes.
  public static func just(_ X: X) -> Signal<X, Error> {
    return Signal { observer in
      observer.next(X)
      observer.completed()
      return NonDisposable.instance
    }
  }

  /// Create a signal that emits given sequence of Xs and then completes.
  public static func sequence<S: Sequence>(_ sequence: S) -> Signal<X, Error> where S.Iterator.Element == X {
    return Signal { observer in
      sequence.forEach(observer.next)
      observer.completed()
      return NonDisposable.instance
    }
  }

  /// Create a signal that completes without emitting any Xs.
  public static func completed() -> Signal<X, Error> {
    return Signal { observer in
      observer.completed()
      return NonDisposable.instance
    }
  }

  /// Create a signal that just terminates with the given error.
  public static func failed(_ error: Error) -> Signal<X, Error> {
    return Signal { observer in
      observer.failed(error)
      return NonDisposable.instance
    }
  }

  /// Create a signal that never completes.
  public static func never() -> Signal<X, Error> {
    return Signal { observer in
      return NonDisposable.instance
    }
  }

  /// Create a signal that emits an integer every `interval` time on a given dispatch queue.
  public static func interval(_ interval: Double, queue: DispatchQueue = DispatchQueue(label: "com.reactivekit.interval")) -> Signal<Int, Error> {
    return Signal { observer in
      var number = 0
      var dispatch: (() -> Void)!
      let disposable = SimpleDisposable()
      dispatch = {
        queue.after(when: interval) {
          guard !disposable.isDisposed else { dispatch = nil; return }
          observer.next(number)
          number = number + 1
          dispatch()
        }
      }
      dispatch()
      return disposable
    }
  }

  /// Create a signal that emits given X after `time` time on a given queue.
  public static func timer(X: X, time: Double, queue: DispatchQueue = DispatchQueue(label: "com.reactivekit.timer")) -> Signal<X, Error> {
    return Signal { observer in
      let disposable = SimpleDisposable()
      queue.after(when: time) {
        guard !disposable.isDisposed else { return }
        observer.next(X)
        observer.completed()
      }
      return disposable
    }
  }
}

// MARK: Transforming signals

public extension SignalProtocol {

  /// Batch the Xs into arrays of given size.
  public func buffer(size: Int) -> Signal<[X], Error> {
    return Signal { observer in
      var buffer: [X] = []
      return self.observe { event in
        switch event {
        case .next(let X):
          buffer.append(X)
          if buffer.count == size {
            observer.next(buffer)
            buffer.removeAll()
          }
        case .failed(let error):
          observer.failed(error)
        case .completed:
          observer.completed()
        }
      }
    }
  }

  /// Maps each X into an optional type and propagates unwrapped .some results.
  /// Shorthand for ```map().ignoreNil()```.
  public func flatMap<U>(_ transform: @escaping (X) -> U?) -> Signal<U, Error> {
    return Signal { observer in
      return self.observe { event in
        switch event {
        case .next(let X):
          if let X = transform(X) {
            observer.next(X)
          }
        case .failed(let error):
          observer.failed(error)
        case .completed:
          observer.completed()
        }
      }
    }
  }

  /// Map each event into a signal and then flatten inner signals.
  public func flatMapLatest<O: SignalProtocol>(_ transform: @escaping (X) -> O) -> Signal<O.X, Error> where O.Error == Error {
    return map(transform).switchToLatest()
  }

  /// Map each event into a signal and then flatten inner signals.
  public func flatMapMerge<O: SignalProtocol>(_ transform: @escaping (X) -> O) -> Signal<O.X, Error> where O.Error == Error {
    return map(transform).merge()
  }

  /// Map each event into a signal and then flatten inner signals.
  public func flatMapConcat<O: SignalProtocol>(_ transform: @escaping (X) -> O) -> Signal<O.X, Error> where O.Error == Error {
    return map(transform).concat()
  }

  /// Map failure event into another operation and continue with that operation. Also called `catch`.
  public func flatMapError<S: SignalProtocol>(_ recover: @escaping (Error) -> S) -> Signal<X, S.Error> where S.X == X {
    return Signal { observer in
      let serialDisposable = SerialDisposable(otherDisposable: nil)

      serialDisposable.otherDisposable = self.observe { taskEvent in
        switch taskEvent {
        case .next(let value):
          observer.next(value)
        case .completed:
          observer.completed()
        case .failed(let error):
          serialDisposable.otherDisposable = recover(error).observe(with: observer.on)
        }
      }

      return serialDisposable
    }
  }

  /// Transform each X by applying `transform` on it.
  public func map<U>(_ transform: @escaping (X) -> U) -> Signal<U, Error> {
    return Signal { observer in
      return self.observe { event in
        switch event {
        case .next(let X):
          observer.next(transform(X))
        case .failed(let error):
          observer.failed(error)
        case .completed:
          observer.completed()
        }
      }
    }
  }

  /// Transform error by applying `transform` on it.
  public func mapError<F>(_ transform: @escaping (Error) -> F) -> Signal<X, F> {
    return Signal { observer in
      return self.observe { event in
        switch event {
        case .next(let X):
          observer.next(X)
        case .failed(let error):
          observer.failed(transform(error))
        case .completed:
          observer.completed()
        }
      }
    }
  }

  /// Replace all emitted Xs with the given X.
  public func replace<T>(with X: T) -> Signal<T, Error> {
    return map { _ in X }
  }

  /// Map Xs to Void.
  public func eraseType() -> Signal<Void, Error> {
    return map { _ in }
  }

  /// Apply `combine` to each X starting with `initial` and emit each
  /// intermediate result. This differs from `reduce` which emits only final result.
  public func scan<U>(_ initial: U, _ combine: @escaping (U, X) -> U) -> Signal<U, Error> {
    return Signal { observer in
      var accumulator = initial
      observer.next(accumulator)
      return self.observe { event in
        switch event {
        case .next(let X):
          accumulator = combine(accumulator, X)
          observer.next(accumulator)
        case .failed(let error):
          observer.failed(error)
        case .completed:
          observer.completed()
        }
      }
    }
  }

  /// Transform each X by applying `transform` on it.
  public func tryMap<U>(_ transform: @escaping (X) -> Result<U, Error>) -> Signal<U, Error> {
    return Signal { observer in
      return self.observe { event in
        switch event {
        case .next(let X):
          switch transform(X) {
          case .success(let value):
            observer.next(value)
          case .failure(let error):
            observer.failed(error)
          }
        case .failed(let error):
          observer.failed(error)
        case .completed:
          observer.completed()
        }
      }
    }
  }

  /// Convert the receiver to a concrete signal.
  public func toSignal() -> Signal<X, Error> {
    if let signal = self as? Signal<X, Error> {
      return signal
    } else {
      return Signal { observer in
        return self.observe(with: observer.on)
      }
    }
  }

  /// Branches out error into another signal.
  public func branchOutError() -> (Signal<X, NoError>, Signal<Error, NoError>) {
    let shared = shareReplay()
    return (shared.suppressError(logging: false), shared.toErrorSignal())
  }

  /// Branches out mapped error into another signal.
  public func branchOutError<F>(_ mapError: @escaping (Error) -> F) -> (Signal<X, NoError>, Signal<F, NoError>) {
    let shared = shareReplay()
    return (shared.suppressError(logging: false), shared.toErrorSignal().map(mapError))
  }

  /// Converts signal into non-failable signal by suppressing the error.
  public func suppressError(logging: Bool, file: String = #file, line: Int = #line) -> Signal<X, NoError> {
    return Signal { observer in
      return self.observe { event in
        switch event {
        case .next(let X):
          observer.next(X)
        case .failed(let error):
          observer.completed()
          if logging {
            print("Signal at \(file):\(line) encountered an error: \(error)")
          }
        case .completed:
          observer.completed()
        }
      }
    }
  }

  /// Converts signal into non-failable signal by feeding suppressed error into a subject.
  public func suppressAndFeedError<S: SubjectProtocol>(into listener: S, logging: Bool = true, file: String = #file, line: Int = #line) -> Signal<X, NoError> where S.X == Error {
    return feedError(into: listener).suppressError(logging: logging, file: file, line: line)
  }

  /// Recovers the signal by propagating default X if error happens.
  public func recover(with X: X) -> Signal<X, NoError> {
    return Signal { observer in
      return self.observe { event in
        switch event {
        case .next(let X):
          observer.next(X)
        case .failed:
          observer.next(X)
          observer.completed()
        case .completed:
          observer.completed()
        }
      }
    }
  }

  /// Maps failable signal into a non-failable signal of errors. Ignores `.next` events.
  public func toErrorSignal() -> Signal<Error, NoError> {
    return Signal { observer in
      return self.observe { taskEvent in
        switch taskEvent {
        case .next:
          break
        case .completed:
          observer.completed()
        case .failed(let error):
          observer.next(error)
        }
      }
    }
  }

  /// Batch each `size` Xs into another signal.
  public func window(size: Int) -> Signal<Signal<X, Error>, Error> {
    return buffer(size: size).map { Signal.sequence($0) }
  }
}

extension SignalProtocol where X: OptionalProtocol {

  /// Apply `transform` to all non-nil Xs.
  public func flatMap<U>(_ transform: @escaping (X.Wrapped) -> U?) -> Signal<U?, Error> {
    return Signal { observer in
      return self.observe { event in
        switch event {
        case .next(let X):
          if let X = X._unbox {
            observer.next(transform(X))
          } else {
            observer.next(nil)
          }
        case .failed(let error):
          observer.failed(error)
        case .completed:
          observer.completed()
        }
      }
    }
  }
}

extension SignalProtocol where X: Sequence {

  /// Map each emitted sequence.
  public func flatMap<U>(_ transform: @escaping (X.Iterator.Element) -> U) -> Signal<[U], Error> {
    return Signal { observer in
      return self.observe { event in
        switch event {
        case .next(let X):
          observer.next(X.map(transform))
        case .failed(let error):
          observer.failed(error)
        case .completed:
          observer.completed()
        }
      }
    }
  }

  /// Unwraps Xs from each emitted sequence into an events of their own.
  public func unwrap() -> Signal<X.Iterator.Element, Error> {
    return Signal { observer in
      return self.observe { event in
        switch event {
        case .next(let sequence):
          sequence.forEach(observer.next)
        case .completed:
          observer.completed()
        case .failed(let error):
          observer.failed(error)
        }
      }
    }
  }
}

// MARK: Filtering signals

public extension SignalProtocol {

  /// Emit an X only if `interval` time passes without emitting another X.
  public func debounce(interval: Double, on queue: DispatchQueue = DispatchQueue(label: "com.reactivekit.debounce")) -> Signal<X, Error> {
    return Signal { observer in
      var timerSubscription: Disposable? = nil
      var previousX: X? = nil
      return self.observe { event in
        timerSubscription?.dispose()
        switch event {
        case .next(let X):
          previousX = X
          timerSubscription = queue.disposableAfter(when: interval) {
            if let _X = previousX {
              observer.next(_X)
              previousX = nil
            }
          }
        case .failed(let error):
          observer.failed(error)
        case .completed:
          if let previousX = previousX {
            observer.next(previousX)
            observer.completed()
          }
        }

      }
    }
  }

  /// Emit first X and then all Xs that are not equal to their predecessor(s).
  public func distinct(areDistinct: @escaping (X, X) -> Bool) -> Signal<X, Error> {
    return Signal { observer in
      var lastX: X? = nil
      return self.observe { event in
        switch event {
        case .next(let X):
          let prevLastX = lastX
          lastX = X
          if prevLastX == nil || areDistinct(prevLastX!, X) {
            observer.next(X)
          }
        default:
          observer.on(event)
        }
      }
    }
  }

  /// Emit only X at given index if such X is produced.
  public func X(at index: Int) -> Signal<X, Error> {
    return Signal { observer in
      var currentIndex = 0
      return self.observe { event in
        switch event {
        case .next(let X):
          if currentIndex == index {
            observer.next(X)
            observer.completed()
          } else {
            currentIndex += 1
          }
        default:
          observer.on(event)
        }
      }
    }
  }

  /// Emit only Xs that pass `include` test.
  public func filter(_ isIncluded: @escaping (X) -> Bool) -> Signal<X, Error> {
    return Signal { observer in
      return self.observe { event in
        switch event {
        case .next(let X):
          if isIncluded(X) {
            observer.next(X)
          }
        default:
          observer.on(event)
        }
      }
    }
  }

  /// Filters the signal by executing `isIncluded` in each X and
  /// propagates that X only if the returned signal fires `true`.
  public func filter(_ isIncluded: @escaping (X) -> SafeSignal<Bool>) -> Signal<X, Error> {
    return flatMapLatest { X -> Signal<X, Error> in
      return isIncluded(X)
        .first()
        .map { isIncluded -> X? in
          if isIncluded {
            return X
          } else {
            return nil
          }
        }
        .ignoreNil()
        .castError()
    }
  }

  /// Emit only the first X generated by the signal and then complete.
  public func first() -> Signal<X, Error> {
    return take(first: 1)
  }

  /// Ignore all Xs (just propagate terminal events).
  public func ignoreXs() -> Signal<X, Error> {
    return filter { _ in false }
  }
  
  /// Ignore all terminal events (just propagate next events).
  public func ignoreTerminal() -> Signal<X, Error> {
    return Signal { observer in
      return self.observe { event in
        if case .next(let X) = event {
          observer.next(X)
        }
      }
    }
  }

  /// Emit only last X generated by the signal and then complete.
  public func last() -> Signal<X, Error> {
    return take(last: 1)
  }

  /// Periodically sample the signal and emit latest X from each interval.
  public func sample(interval: Double, on queue: DispatchQueue = DispatchQueue(label: "com.reactivekit.sample")) -> Signal<X, Error> {
    return Signal { observer in
      let serialDisposable = SerialDisposable(otherDisposable: nil)
      var latestX: X? = nil
      var dispatch: (() -> Void)!
      dispatch = {
        queue.after(when: interval) {
          guard !serialDisposable.isDisposed else { dispatch = nil; return }
          if let X = latestX {
            observer.next(X)
            latestX = nil
          }
          dispatch()
        }
      }

      serialDisposable.otherDisposable = self.observe { event in
        switch event {
        case .next(let X):
          latestX = X
        default:
          observer.on(event)
          serialDisposable.dispose()
        }
      }

      dispatch()
      return serialDisposable
    }
  }

  /// Suppress first `count` Xs generated by the signal.
  public func skip(first count: Int) -> Signal<X, Error> {
    return Signal { observer in
      var count = count
      return self.observe { event in
        switch event {
        case .next(let X):
          if count > 0 {
            count -= 1
          } else {
            observer.next(X)
          }
        default:
          observer.on(event)
        }
      }
    }
  }

  /// Suppress last `count` Xs generated by the signal.
  public func skip(last count: Int) -> Signal<X, Error> {
    guard count > 0 else { return self.toSignal() }
    return Signal { observer in
      var buffer: [X] = []
      return self.observe { event in
        switch event {
        case .next(let X):
          buffer.append(X)
          if buffer.count > count {
            observer.next(buffer.removeFirst())
          }
        default:
          observer.on(event)
        }
      }
    }
  }

  /// Suppress Xs for first `interval` seconds.
  public func skip(interval: Double) -> Signal<X, Error> {
    return Signal { observer in
      let startTime = Date().addingTimeInterval(interval)
      return self.observe { event in
        switch event {
        case .next:
          if startTime < Date() {
            observer.on(event)
          }
        case .completed, .failed:
          observer.on(event)
        }
      }
    }
  }

  /// Emit only first `count` Xs of the signal and then complete.
  public func take(first count: Int) -> Signal<X, Error> {
    return Signal { observer in
      guard count > 0 else {
        observer.completed()
        return NonDisposable.instance
      }

      var taken = 0

      let serialDisposable = SerialDisposable(otherDisposable: nil)
      serialDisposable.otherDisposable = self.observe { event in
        switch event {
        case .next(let X):
          if taken < count {
            taken += 1
            observer.next(X)
          }
          if taken == count {
            observer.completed()
            serialDisposable.otherDisposable?.dispose()
          }
        default:
          observer.on(event)
        }
      }
      return serialDisposable
    }
  }

  /// Emit only last `count` Xs of the signal and then complete.
  public func take(last count: Int) -> Signal<X, Error> {
    return Signal { observer in
      var values: [X] = []
      values.reserveCapacity(count)
      return self.observe(with: { (event) in
        switch event {
        case .completed:
          values.forEach(observer.next)
          observer.completed()
        case .failed(let error):
          observer.failed(error)
        case .next(let X):
          if event.isTerminal {
            observer.on(event)
          } else {
            if values.count + 1 > count {
              values.removeFirst(values.count - count + 1)
            }
            values.append(X)
          }
        }
      })
    }
  }

  /// Emit Xs of the reciver until given signal completes and then complete the receiver.
  public func take<S: SignalProtocol>(until signal: S) -> Signal<X, Error> {
    return Signal { observer in
      let disposable = CompositeDisposable()

      disposable += signal.observe { event in
        observer.completed()
      }

      disposable += self.observe { event in
        switch event {
        case .completed:
          observer.completed()
        case .failed(let error):
          observer.failed(error)
        case .next(let X):
          observer.next(X)
        }
      }

      return disposable
    }
  }

  /// Throttle the signal to emit at most one X per given `seconds` interval.
  public func throttle(seconds: Double) -> Signal<X, Error> {
    return Signal { observer in
      var lastEventTime: DispatchTime?
      return self.observe { event in
        switch event {
        case .next(let X):
          let now = DispatchTime.now()
          if lastEventTime == nil || now.rawValue > (lastEventTime! + seconds).rawValue {
            lastEventTime = now
            observer.next(X)
          }
        default:
          observer.on(event)
        }
      }
    }
  }
}

public extension SignalProtocol where X: Equatable {

  /// Emit first X and then all Xs that are not equal to their predecessor(s).
  public func distinct() -> Signal<X, Error> {
    return distinct(areDistinct: !=)
  }
}

public extension SignalProtocol where X: OptionalProtocol, X.Wrapped: Equatable {
  
  /// Emit first X and then all Xs that are not equal to their predecessor(s).
  public func distinct() -> Signal<X, Error> {
    return distinct(areDistinct: !=)
  }
}

public extension SignalProtocol where X: OptionalProtocol {

  /// Suppress all `nil`-Xs.
  public func ignoreNil() -> Signal<X.Wrapped, Error> {
    return Signal { observer in
      return self.observe { event in
        switch event {
        case .next(let X):
          if let X = X._unbox {
            observer.next(X)
          }
        case .failed(let error):
          observer.failed(error)
        case .completed:
          observer.completed()
        }
      }
    }
  }

  /// Replace all `nil`-Xs with the provided replacement.
  public func replaceNil(with replacement: X.Wrapped) -> Signal<X.Wrapped, Error> {
    return Signal { observer in
      return self.observe { event in
        switch event {
        case .next(let X):
          if let X = X._unbox {
            observer.next(X)
          } else {
            observer.next(replacement)
          }
        case .failed(let error):
          observer.failed(error)
        case .completed:
          observer.completed()
        }
      }
    }
  }
}

//  MARK: Utilities

extension SignalProtocol {

  /// Set the execution context in which to execute the signal (i.e. in which to run
  /// the signal's producer).
  public func executeIn(_ context: ExecutionContext) -> Signal<X, Error> {
    return Signal { observer in
      let serialDisposable = SerialDisposable(otherDisposable: nil)
      context.execute {
        if !serialDisposable.isDisposed {
          serialDisposable.otherDisposable = self.observe(with: observer.on)
        }
      }
      return serialDisposable
    }
  }

  /// Set the dispatch queue on which to execute the signal (i.e. in which to run
  /// the signal's producer).
  public func executeOn(_ queue: DispatchQueue) -> Signal<X, Error> {
    return Signal { observer in
      let serialDisposable = SerialDisposable(otherDisposable: nil)
      queue.async {
        if !serialDisposable.isDisposed {
          serialDisposable.otherDisposable = self.observe(with: observer.on)
        }
      }
      return serialDisposable
    }
  }

  /// Delay signal events for `interval` time.
  public func delay(interval: Double, on queue: DispatchQueue = DispatchQueue(label: "com.reactivekit.delay")) -> Signal<X, Error> {
    return Signal { observer in
      return self.observe { event in
        queue.after(when: interval) {
          observer.on(event)
        }
      }
    }
  }

  /// Do side-effect upon various events.
  public func doOn(next: ((X) -> ())? = nil,
                   start: (() -> Void)? = nil,
                   failed: ((Error) -> Void)? = nil,
                   completed: (() -> Void)? = nil,
                   disposed: (() -> ())? = nil) -> Signal<X, Error> {
    return Signal { observer in
      start?()
      let disposable = self.observe { event in
        switch event {
        case .next(let value):
          next?(value)
        case .failed(let error):
          failed?(error)
        case .completed:
          completed?()
        }
        observer.on(event)
      }
      return BlockDisposable {
        disposable.dispose()
        disposed?()
      }
    }
  }

  /// Log various signal events. If title is not provided, source file and function names are printed instead.
  public func debug(_ title: String? = nil, file: String = #file, function: String = #function, line: Int = #line) -> Signal<X, Error> {
    let prefix: String
    if let title = title {
      prefix = "[\(title)]"
    } else {
      let filename = file.components(separatedBy: "/").last ?? file
      prefix = "[\(filename):\(function):\(line)]"
    }

    return doOn(next: { X in
        print("\(prefix) next(\(X))")
      }, start: {
        print("\(prefix) started")
      }, failed: { error in
        print("\(prefix) failed: \(error)")
      }, completed: {
        print("\(prefix) completed")
      }, disposed: {
        print("\(prefix) disposed")
    })
  }

  /// Set the execution context used to dispatch events (i.e. to run the observers).
  public func observeIn(_ context: ExecutionContext) -> Signal<X, Error> {
    return Signal { observer in
      return self.observe { event in
        context.execute {
          observer.on(event)
        }
      }
    }
  }

  /// Set the dispatch queue used to dispatch events (i.e. to run the observers).
  public func observeOn(_ queue: DispatchQueue) -> Signal<X, Error> {
    return Signal { observer in
      return self.observe { event in
        queue.async {
          observer.on(event)
        }
      }
    }
  }

  /// Supress events while last event generated on other signal is `false`.
  public func pausable<O: SignalProtocol>(by: O) -> Signal<X, Error> where O.X == Bool {
    return Signal { observer in
      var allowed: Bool = true
      let compositeDisposable = CompositeDisposable()

      compositeDisposable += by.observeNext { value in
        allowed = value
      }

      compositeDisposable += self.observe { event in
        if event.isTerminal || allowed {
          observer.on(event)
        }
      }

      return compositeDisposable
    }
  }

  /// Restart the operation in case of failure at most `times` number of times.
  public func retry(times: Int) -> Signal<X, Error> {
    guard times > 0 else { return toSignal() }

    return Signal { observer in
      var remainingAttempts = times
      let serialDisposable = SerialDisposable(otherDisposable: nil)
      var attempt: (() -> Void)?
      attempt = {
        serialDisposable.otherDisposable?.dispose()
        serialDisposable.otherDisposable = self.observe { event in
          switch event {
          case .next(let X):
            observer.next(X)
          case .failed(let error):
            if remainingAttempts > 0 {
              remainingAttempts -= 1
              attempt?()
            } else {
              attempt = nil
              observer.failed(error)
            }
          case .completed:
            attempt = nil
            observer.completed()
          }
        }
      }
      attempt?()
      return BlockDisposable {
        serialDisposable.dispose()
        attempt = nil
      }
    }
  }

  /// Retries the failed signal when other signal produces an X.
  public func retry<S: SignalProtocol>(when other: S) -> Signal<X, Error> where S.Error == NoError {
    return Signal { observer in
      let serialDisposable = SerialDisposable(otherDisposable: nil)
      var attempt: (() -> Void)?
      attempt = {
        serialDisposable.otherDisposable?.dispose()
        let compositeDisposable = CompositeDisposable()
        serialDisposable.otherDisposable = compositeDisposable
        compositeDisposable += self.observe { event in
          switch event {
          case .next(let X):
            observer.next(X)
          case .completed:
            attempt = nil
            observer.completed()
          case .failed(let error):
            compositeDisposable += other.observe { otherEvent in
              switch otherEvent {
              case .next:
                attempt?()
              case .completed, .failed:
                attempt = nil
                observer.failed(error)
              }
            }
          }
        }
      }
      attempt?()
      return serialDisposable
    }
  }

  /// Error-out if `interval` time passes with no emitted Xs.
  public func timeout(after interval: Double, with error: Error, on queue: DispatchQueue = DispatchQueue(label: "com.reactivekit.timeout")) -> Signal<X, Error> {
    return Signal { observer in
      var completed = false
      let timeoutWhenCan: () -> Disposable = {
        return queue.disposableAfter(when: interval) {
          if !completed {
            completed = true
            observer.failed(error)
          }
        }
      }
      var lastSubscription = timeoutWhenCan()
      return self.observe { event in
        lastSubscription.dispose()
        observer.on(event)
        completed = event.isTerminal
        lastSubscription = timeoutWhenCan()
      }
    }
  }

  /// Collect all Xs into an array and emit just that array.
  public func collect() -> Signal<[X], Error> {
    return reduce([], { memo, new in memo + [new] })
  }

  /// First emit events from source and then from `other` signal.
  public func concat(with other: Signal<X, Error>) -> Signal<X, Error> {
    return Signal { observer in
      let serialDisposable = SerialDisposable(otherDisposable: nil)
      serialDisposable.otherDisposable = self.observe { event in
        switch event {
        case .next(let X):
          observer.next(X)
        case .failed(let error):
          observer.failed(error)
        case .completed:
          serialDisposable.otherDisposable = other.observe(with: observer.on)
        }
      }
      return serialDisposable
    }
  }

  /// Emit default X if signal completes without emitting any X.
  public func defaultIfEmpty(_ X: X) -> Signal<X, Error> {
    return Signal { observer in
      var didEmitNonTerminal = false
      return self.observe { event in
        switch event {
        case .next(let X):
          didEmitNonTerminal = true
          observer.next(X)
        case .failed(let error):
          observer.failed(error)
        case .completed:
          if !didEmitNonTerminal {
            observer.next(X)
          }
          observer.completed()
        }
      }
    }
  }

  /// Reduce signal events to a single event by applying given function on each emission.
  public func reduce<U>(_ initial: U, _ combine: @escaping (U, X) -> U) -> Signal<U, Error> {
    return scan(initial, combine).take(last: 1)
  }

  /// Replays the latest X when other signal fires an X.
  public func replayLatest<S: SignalProtocol>(when other: S) -> Signal<X, Error> where S.Error == NoError {
    return Signal { observer in
      var latest: X? = nil
      let disposable = CompositeDisposable()

      disposable += other.observe { event in
        switch event {
        case .next:
          if let latest = latest {
            observer.next(latest)
          }
        case .failed, .completed:
          break
        }
      }

      disposable += self.observe { event in
        switch event {
        case .next(let X):
          latest = X
          observer.next(X)
        case .failed(let error):
          observer.failed(error)
        case .completed:
          observer.completed()
        }
      }

      return disposable
    }
  }

  /// Prepend the given X to the signal emission.
  public func start(with X: X) -> Signal<X, Error> {
    return Signal { observer in
      observer.next(X)
      return self.observe { event in
        observer.on(event)
      }
    }
  }

  /// Par each X with its predecessor. First X is paired with `nil`.
  public func zipPrevious() -> Signal<(X?, X), Error> {
    return Signal { observer in
      var previous: X? = nil
      return self.observe { event in
        switch event {
        case .next(let X):
          let lastPrevious = previous
          previous = X
          observer.next((lastPrevious, X))
        case .failed(let error):
          observer.failed(error)
        case .completed:
          observer.completed()
        }
      }
    }
  }

  /// Wrap events into Xs.
  public func materialize() -> Signal<Event<X, Error>, NoError> {
    return Signal { observer in
      return self.observe { event in
        switch event {
        case .next(let X):
          observer.next(.next(X))
        case .failed(let error):
          observer.next(.failed(error))
          observer.completed()
        case .completed:
          observer.next(.completed)
          observer.completed()
        }
      }
    }
  }
}

// MARK: Injections

extension SignalProtocol {

  /// Update the given subject with `true` when the receiver starts and with `false` when the receiver terminates.
  public func feedActivity<S: SubjectProtocol>(into listener: S) -> Signal<X, Error> where S.X == Bool {
    return doOn(start: { listener.next(true) }, disposed: { listener.next(false) })
  };

  /// Update the given subject with `.next` Xs.
  public func feedNext<S: SubjectProtocol>(into listener: S) -> Signal<X, Error> where S.X == X {
    return doOn(next: { e in listener.next(e) })
  }

  /// Update the given subject with mapped `.next` X whenever the X satisfies the given constraint.
  public func feedNext<S: SubjectProtocol>(into listener: S, when: @escaping (X) -> Bool = { _ in true }, map: @escaping (X) -> S.X) -> Signal<X, Error> {
    return doOn(next: { e in if when(e) { listener.next(map(e)) } })
  }

  /// Updates the given subject with error from .failed event is such occurs.
  public func feedError<S: SubjectProtocol>(into listener: S) -> Signal<X, Error> where S.X == Error {
    return doOn(failed: { e in listener.next(e) })
  }
}

// MARK: Signals that emit other signals

public extension SignalProtocol where X: SignalProtocol, X.Error == Error {

  public typealias InnerX = X.X

  /// Flatten the signal by observing all inner signals and propagate events from each one as they come.
  public func merge() -> Signal<InnerX, Error> {
    return Signal { observer in
      let lock = NSRecursiveLock(name: "com.reactivekit.merge")
      let compositeDisposable = CompositeDisposable()
      var numberOfOperations = 1 // 1 for outer signal

      func decrementNumberOfOperations() {
          numberOfOperations -= 1
          if numberOfOperations == 0 {
            observer.completed()
          }
      }

      compositeDisposable += self.observe { outerEvent in
        switch outerEvent {
        case .next(let innerSignal):
          lock.lock()
          numberOfOperations += 1
          compositeDisposable += innerSignal.observe { innerEvent in
            switch innerEvent {
            case .next(let X):
              observer.next(X)
            case .failed(let error):
              observer.failed(error)
            case .completed:
              decrementNumberOfOperations()
            }
          }
          lock.unlock()
        case .failed(let error):
          observer.failed(error)
        case .completed:
          lock.lock()
          decrementNumberOfOperations()
          lock.unlock()
        }
      }

      return compositeDisposable
    }
  }

  /// Flatten the signal by observing and propagating emissions only from latest signal.
  public func switchToLatest() -> Signal<InnerX, Error> {
    return Signal { observer in
      let serialDisposable = SerialDisposable(otherDisposable: nil)
      let compositeDisposable = CompositeDisposable([serialDisposable])
      var completions = (outer: false, inner: false)
      let lock = NSRecursiveLock(name: "com.reactivekit.switchtolatest")

      compositeDisposable += self.observe { outerEvent in
        switch outerEvent {
        case .next(let innerSignal):
          lock.lock()
          completions.inner = false
          serialDisposable.otherDisposable?.dispose()
          serialDisposable.otherDisposable = innerSignal.observe { innerEvent in
            switch innerEvent {
            case .next(let X):
              observer.next(X)
            case .failed(let error):
              observer.failed(error)
            case .completed:
              lock.lock()
              completions.inner = true
              if completions.outer {
                observer.completed()
              }
              lock.unlock()
            }
          }
          lock.unlock()
        case .failed(let error):
          observer.failed(error)
        case .completed:
          lock.lock()
          completions.outer = true
          if completions.inner {
            observer.completed()
          }
          lock.unlock()
        }
      }

      return compositeDisposable
    }
  }

  /// Flatten the signal by sequentially observing inner signals in order in which they
  /// arrive, starting next observation only after previous one completes.
  public func concat() -> Signal<InnerX, Error> {
    return Signal { observer in
      let lock = NSRecursiveLock(name: "com.reactivekit.concat")
      let serialDisposable = SerialDisposable(otherDisposable: nil)
      let compositeDisposable = CompositeDisposable([serialDisposable])
      var completions = (outer: false, inner: true)
      var innerSignalQueue: [X] = []

      func startNextOperation() {
        completions.inner = false

        let innerSignal = innerSignalQueue.removeFirst()

        serialDisposable.otherDisposable?.dispose()
        serialDisposable.otherDisposable = innerSignal.observe { event in
          switch event {
          case .next(let X):
            observer.next(X)
          case .failed(let error):
            observer.failed(error)
          case .completed:
            lock.lock()
            completions.inner = true
            if !innerSignalQueue.isEmpty {
              startNextOperation()
            } else if completions.outer {
              observer.completed()
            }
            lock.unlock()
          }
        }
      }

      func addToQueue(signal: X) {
        lock.lock()
        innerSignalQueue.append(signal)
        if completions.inner {
          startNextOperation()
        }
        lock.unlock()
      }

      compositeDisposable += self.observe { outerEvent in
        switch outerEvent {
        case .next(let innerSignal):
          addToQueue(signal: innerSignal)
        case .failed(let error):
          observer.failed(error)
        case .completed:
          lock.lock()
          completions.outer = true
          if completions.inner {
            observer.completed()
          }
          lock.unlock()
        }
      }
      
      return compositeDisposable
    }
  }
}

// MARK: Combinational

extension SignalProtocol {

  fileprivate func _amb<O: SignalProtocol>(with other: O) -> Signal<X, Error> where O.X == X, O.Error == Error {
    return Signal { observer in
      let lock = NSRecursiveLock(name: "com.reactivekit.amb")
      let disposable = (my: SerialDisposable(otherDisposable: nil), other: SerialDisposable(otherDisposable: nil))
      var dispatching = (me: false, other: false)

      disposable.my.otherDisposable = self.observe { event in
        lock.lock(); defer { lock.unlock() }
        guard !dispatching.other else { return }
        dispatching.me = true
        observer.on(event)
        if !disposable.other.isDisposed {
          disposable.other.dispose()
        }
      }

      disposable.other.otherDisposable = other.observe { event in
        lock.lock(); defer { lock.unlock() }
        guard !dispatching.me else { return }
        dispatching.other = true
        observer.on(event)
        if !disposable.my.isDisposed {
          disposable.my.dispose()
        }
      }

      return CompositeDisposable([disposable.my, disposable.other])
    }
  }

  /// Propagate events only from a signal that starts emitting first.
  public func amb<O: SignalProtocol>(with other: O) -> Signal<X, Error> where O.X == X, O.Error == Error {
    return _amb(with: other)
  }

  fileprivate func _combineLatest<O: SignalProtocol, U>(with other: O, combine: @escaping (X, O.X) -> U) -> Signal<U, Error> where O.Error == Error {
    return Signal { observer in
      let lock = NSRecursiveLock(name: "com.reactivekit.combinelatestwith")

      var Xs: (my: X?, other: O.X?)
      var completions: (me: Bool, other: Bool) = (false, false)
      let compositeDisposable = CompositeDisposable()

      func onAnyNext() {
        if let myX = Xs.my, let otherX = Xs.other {
          let combination = combine(myX, otherX)
          observer.next(combination)
        }
      }

      func onAnyCompleted() {
        if completions.me == true && completions.other == true {
          observer.completed()
        }
      }

      compositeDisposable += self.observe { event in
        lock.lock(); defer { lock.unlock() }
        switch event {
        case .next(let X):
          Xs.my = X
          onAnyNext()
        case .failed(let error):
          observer.failed(error)
        case .completed:
          completions.me = true
          onAnyCompleted()
        }
      }

      compositeDisposable += other.observe { event in
        lock.lock(); defer { lock.unlock() }
        switch event {
        case .next(let X):
          Xs.other = X
          onAnyNext()
        case .failed(let error):
          observer.failed(error)
        case .completed:
          completions.other = true
          onAnyCompleted()
        }
      }

      return compositeDisposable
    }
  }

  /// Emit a combination of latest Xs from each signal. Starts when both signals emit at least one X,
  /// and emits `.next` when either signal generates an X by calling `combine` on the two latest Xs.
  public func combineLatest<O: SignalProtocol, U>(with other: O, combine: @escaping (X, O.X) -> U) -> Signal<U, Error> where O.Error == Error {
    return _combineLatest(with: other, combine: combine)
  }

  /// Emit a pair of latest Xs from each signal. Starts when both signals emit at least one X,
  /// and emits `.next` when either signal generates an X.
  public func combineLatest<O: SignalProtocol>(with other: O) -> Signal<(X, O.X), Error> where O.Error == Error {
    return _combineLatest(with: other, combine: { ($0, $1) })
  }

  /// Merge emissions from both the receiver and the other signal into one signal.
  public func merge<O: SignalProtocol>(with other: O) -> Signal<X, Error> where O.X == X, O.Error == Error {
    return Signal.sequence([self.toSignal(), other.toSignal()]).merge()
  }

  fileprivate func _zip<O: SignalProtocol, U>(with other: O, combine: @escaping (X, O.X) -> U) -> Signal<U, Error> where O.Error == Error {
    return Signal { observer in
      let lock = NSRecursiveLock(name: "zip")

      var buffers: (my: [X], other: [O.X]) = ([], [])
      var completions: (me: Bool, other: Bool) = (false, false)
      let compositeDisposable = CompositeDisposable()

      let dispatchIfPossible = {
        while !buffers.my.isEmpty && !buffers.other.isEmpty {
          let X = combine(buffers.my[0], buffers.other[0])
          observer.next(X)
          buffers.my.removeFirst()
          buffers.other.removeFirst()
        }
      }

      func completeIfPossible() {
        if (buffers.my.isEmpty && completions.me) || (buffers.other.isEmpty && completions.other) {
          observer.completed()
        }
      }

      compositeDisposable += self.observe { event in
        lock.lock(); defer { lock.unlock() }
        switch event {
        case .next(let X):
          buffers.my.append(X)
        case .failed(let error):
          observer.failed(error)
        case .completed:
          completions.me = true
        }
        dispatchIfPossible()
        completeIfPossible()
      }

      compositeDisposable += other.observe { event in
        lock.lock(); defer { lock.unlock() }
        switch event {
        case .next(let X):
          buffers.other.append(X)
        case .failed(let error):
          observer.failed(error)
        case .completed:
          completions.other = true
        }
        dispatchIfPossible()
        completeIfPossible()
      }

      return compositeDisposable
    }
  }

  /// Emit Xs from the receiver and the other signal in pairs.
  /// This differs from `combineLatest` in that the combinations are produced from Xs at same positions.
  public func zip<O: SignalProtocol, U>(with other: O, combine: @escaping (X, O.X) -> U) -> Signal<U, Error> where O.Error == Error {
    return _zip(with: other, combine: combine)
  }

  /// Emit Xs from the receiver and the other signal in pairs.
  /// This differs from `combineLatest` in that the pairs are produced from Xs at same positions.
  public func zip<O: SignalProtocol>(with other: O) -> Signal<(X, O.X), Error> where O.Error == Error {
    return _zip(with: other, combine: { ($0, $1) })
  }

  fileprivate func _with<O: SignalProtocol, U>(latestFrom other: O, combine: @escaping (X, O.X) -> U) -> Signal<U, Error> where O.Error == Error {
    return Signal { observer in

      var latest: O.X? = nil
      let compositeDisposable = CompositeDisposable()

      compositeDisposable += other.observe { event in
        switch event {
        case .next(let X):
          latest = X
        case .failed(let error):
          observer.failed(error)
        case .completed:
          break
        }
      }

      compositeDisposable += self.observe { event in
        switch event {
        case .completed:
          observer.completed()
        case .failed(let error):
          observer.failed(error)
        case .next(let X):
          if let latest = latest {
            observer.next(combine(X, latest))
          }
        }
      }

      return compositeDisposable
    }
  }

  /// Combines the receiver and the other signal into a signal of combinations of Xs whenever the
  /// receiver emits an X with the latest X from the other signal.
  public func with<O: SignalProtocol, U>(latestFrom other: O, combine: @escaping (X, O.X) -> U) -> Signal<U, Error> where O.Error == Error {
    return _with(latestFrom: other, combine: combine)
  }

  /// Combines the receiver and the other signal into a signal of pairs of Xs whenever the
  /// receiver emits an X with the latest X from the other signal.
  public func with<O: SignalProtocol>(latestFrom other: O) -> Signal<(X, O.X), Error> where O.Error == Error {
    return _with(latestFrom: other, combine: { ($0, $1) })
  }
}

extension SignalProtocol where Error == NoError {

  /// Safe error casting from NoError to some Error type.
  public func castError<E>() -> Signal<X, E> {
    return Signal { observer in
      return self.observe { event in
        switch event {
        case .next(let X):
          observer.next(X)
        case .completed:
          observer.completed()
        case .failed:
          break // will never happen because of NoError constraint
        }
      }
    }
  }

  /// Map each event into a signal and then flatten inner signals.
  public func flatMapLatest<O: SignalProtocol>(_ transform: @escaping (X) -> O) -> Signal<O.X, O.Error> {
    return castError().map(transform).switchToLatest()
  }

  /// Map each event into a signal and then flatten inner signals.
  public func flatMapMerge<O: SignalProtocol>(_ transform: @escaping (X) -> O) -> Signal<O.X, O.Error> {
    return castError().map(transform).merge()
  }

  /// Map each event into a signal and then flatten inner signals.
  public func flatMapConcat<O: SignalProtocol>(_ transform: @escaping (X) -> O) -> Signal<O.X, O.Error>  {
    return castError().map(transform).concat()
  }

  /// Transform each X by applying `transform` on it.
  public func tryMap<U, E>(_ transform: @escaping (X) -> Result<U, E>) -> Signal<U, E> {
    return Signal { observer in
      return self.observe { event in
        switch event {
        case .next(let X):
          switch transform(X) {
          case .success(let value):
            observer.next(value)
          case .failure(let error):
            observer.failed(error)
          }
        case .failed:
          break  // will never happen because of NoError constraint
        case .completed:
          observer.completed()
        }
      }
    }
  }

  /// Propagate events only from a signal that starts emitting first.
  public func amb<O: SignalProtocol>(with other: O) -> Signal<X, O.Error> where O.X == X {
    return castError()._amb(with: other)
  }

  /// Emit a combination of latest Xs from each signal. Starts when both signals emit at least one X,
  /// and emits `.next` when either signal generates an X by calling `combine` on the two latest Xs.
  public func combineLatest<O: SignalProtocol, U>(with other: O, combine: @escaping (X, O.X) -> U) -> Signal<U, O.Error> {
    return castError()._combineLatest(with: other, combine: combine)
  }

  /// Emit a pair of latest Xs from each signal. Starts when both signals emit at least one X,
  /// and emits `.next` when either signal generates an X.
  public func combineLatest<O: SignalProtocol>(with other: O) -> Signal<(X, O.X), O.Error> {
    return castError()._combineLatest(with: other, combine: { ($0, $1) })
  }

  /// Merge emissions from both the receiver and the other signal into one signal.
  public func merge<O: SignalProtocol>(with other: O) -> Signal<X, O.Error> where O.X == X {
    return Signal.sequence([toSignal().castError(), other.toSignal()]).merge()
  }

  /// Emit Xs from the receiver and the other signal in pairs.
  /// This differs from `combineLatest` in that the combinations are produced from Xs at same positions.
  public func zip<O: SignalProtocol, U>(with other: O, combine: @escaping (X, O.X) -> U) -> Signal<U, O.Error> {
    return castError()._zip(with: other, combine: combine)
  }

  /// Emit Xs from the receiver and the other signal in pairs.
  /// This differs from `combineLatest` in that the pairs are produced from Xs at same positions.
  public func zip<O: SignalProtocol>(with other: O) -> Signal<(X, O.X), O.Error> {
    return castError()._zip(with: other, combine: { ($0, $1) })
  }

  /// Combines the receiver and the other signal into a signal of combinations of Xs whenever the
  /// receiver emits an X with the latest X from the other signal.
  public func with<O: SignalProtocol, U>(latestFrom other: O, combine: @escaping (X, O.X) -> U) -> Signal<U, O.Error> {
    return castError()._with(latestFrom: other, combine: combine)
  }

  /// Combines the receiver and the other signal into a signal of pairs of Xs whenever the
  /// receiver emits an X with the latest X from the other signal.
  public func with<O: SignalProtocol>(latestFrom other: O) -> Signal<(X, O.X), O.Error> {
    return castError()._with(latestFrom: other, combine: { ($0, $1) })
  }
}

// MARK: Standalone functions

/// Combine an array of signals into one. See `combineLatest(with:)` for more info.
public func combineLatest<X, Result, Error>(_ signals: [Signal<X, Error>], combine: @escaping ([X]) -> Result) -> Signal<Result, Error> {
  return Signal { observer in
    let disposable = CompositeDisposable()
    var Xs = Array<X?>(repeating: nil, count: signals.count)
    var completions = Array(repeating: false, count: signals.count)

    for (idx, signal) in signals.enumerated() {
      disposable += signal.observe { event in
        switch event {
        case .next(let X):
          Xs[idx] = X
          if Xs.reduce(true, { $0 && ($1 != nil) }) {
            observer.next(combine(Xs.map { $0! }))
          }
        case .failed(let error):
          observer.failed(error)
        case .completed:
          completions[idx] = true
          if completions.reduce(true, { $0 && $1 }) {
            observer.completed()
          }
        }
      }
    }

    return disposable
  }
}

/// Merge an array of signals into one. See `merge(with:)` for more info.
public func merge<X, Error>(_ signals: [Signal<X, Error>]) -> Signal<X, Error> {
  return Signal { observer in
    
    guard signals.count > 0 else {
      observer.completed()
      return NonDisposable.instance
    }

    let disposable = CompositeDisposable()
    var completions = Array(repeating: false, count: signals.count)

    for (idx, signal) in signals.enumerated() {
      disposable += signal.observe { event in
        switch event {
        case .next(let X):
          observer.next(X)
        case .failed(let error):
          observer.failed(error)
        case .completed:
          completions[idx] = true
          if completions.reduce(true, { $0 && $1 }) {
            observer.completed()
          }
        }
      }
    }

    return disposable
  }
}

